---
title: 两种次短路--最短路建模
date: 2019-07-21 10:31:13
tags:
- 图
categories:
- 算法
---

### 两种次短路

对于一个带权图，求两个顶点之间的次短路。次短路表示除最短路以外长度最小的路径。

实际上我们遇到的次短路问题分成两种，第一种次短路中可以重复经过一个点，第二种次短路不能重复经过一个点的。而这一个区别会导致解法上的很大区别。

1. 对于第一种可以重复经过某个点的次短路，解法其实和求最短路相似，在进行 dijkstra 的过程中记录两个数组：dist0 和 dist1，分别表示最短路和次短路的答案。每次更新时需要依次判断是否可以更新次短路和最短路的值。由于需要计算次短路，所以调整后的 dijkstra 算法需要至少循环 2n−1 次才可以获得最终答案。

2. 对于第二种不可以重复经过点的次短路，解法也比较直观简单，枚举两个顶点之间最短路上的每条边，每次在去掉这条边的剩下的图中计算最短路，取其中最小的一个答案就是最终次短路的答案。

比如下面这个图

 ![](https://raw.githubusercontent.com/zhanyeye/Figure-bed/img/img/20190728104647.png)

1 - 3 的最短路为 1 -> 2 -> 3，长度为 2。

第一种次短路为 1 -> 2 -> 1 -> 2 -> 3，长度为 4。

第二种次短路为 1 -> 3，长度为 10。













###### 第2种:

蒜头君陷入了坐标系上的一个迷阵，迷阵上有 *n* 个点，编号从 1 到 *n*。蒜头君在编号为 1 的位置，他想到编号为 *n* 的位置上。蒜头君当然想尽快到达目的地，但是他觉得最短的路径可能有风险，所以他会选择第二短的路径。现在蒜头君知道了 *n* 个点的坐标，以及哪些点之间是相连的，他想知道第二短的路径长度是多少。

**注意，每条路径上不能重复经过同一个点**。

**输入格式**

第一行输入两个整数 *n* (1≤*n*≤200) 和 *m*，表示一共有 *n* 个点和 *m* 条边。

接下来输入 *n* 行，每行输入两个整数 x_i, y_i(−500≤ x_i, y_i ≤500)，代表第 *i* 个点的坐标。

接下来输入 *m* 行，每行输入两个整数 p_j, q_j (1≤ p_j, q_j ≤*n*)，表示点 p_j和点 q_j 之间相连。

**输出格式**

输出一行，输出包含一个数，表示第二短的路径长度（小数点后面保留两位），如果第一短路径有多条，则答案就是第一最短路径的长度；如果第二最短路径不存在，则输出 −1。

**样例输入复制**

```
3 3
1 1
2 2
3 2
1 2
2 3
1 3
```

**样例输出复制**

```
2.41
```
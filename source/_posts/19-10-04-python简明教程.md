---
title: 19-10-04 python简明教程
mathjax: true
date: 2019-10-04 09:14:43
tags:
categories:
---



##### 变量和数据类型

###### python 关键字

下列的标识符是 Python3 的关键字，并且不能用于通常的标识符。关键字必须完全按照下面拼写：

```
False               def                 if                  raise
None                del                 import              return
True                elif                in                  try
and                 else                is                  while
as                  except              lambda              with
assert              finally             nonlocal            yield
break               for                 not                 
class               from                or                  
continue            global              pass
```

<!--more-->

###### 变量的定义与赋值

在 Python 中 我们不需要为变量指定数据类型。所以你可以直接写出 `abc = 1` ，这样变量 `abc` 就是整数类型。如果你写出 `abc = 1.0` ，那么变量 `abc` 就是浮点类型。

Python 也能操作字符串，它们用单引号或双引号括起来，就像下面这样。

```
>>> 'ShiYanLou'
'ShiYanLou' 
>>> 'ShiYanLou\'s best' 
"ShiYanLou's best" 
>>> "Hello World!" 
'Hello World!'
```

###### input() 函数

通常情况下，Python 的代码中是不需要从键盘读取输入的。不过我们还是可以在 Python 中使用函数 `input()` 来做到这一点，`input()` 有一个用于打印在屏幕上的可选字符串参数，返回用户输入的字符串

```python
#!/usr/bin/env python3
number = int(input("Enter an integer: "))
if number <= 100:
    print("Your number is less than or equal to 100")
else:
    print("Your number is greater than 100")
```

###### 字符串的格式化

```python
>>>"{} {}".format("hello", "world")    # 不设置指定位置，按默认顺序
'hello world'
 
>>> "{0} {1}".format("hello", "world")  # 设置指定位置
'hello world'
 
>>> "{1} {0} {1}".format("hello", "world")  # 设置指定位置
'world hello world'
```

| 3.1415926  |                            {:.2f}                            | 3.14                                          | 保留小数点后两位             |
| ---------- | :----------------------------------------------------------: | --------------------------------------------- | ---------------------------- |
| 3.1415926  |                           {:+.2f}                            | +3.14                                         | 带符号保留小数点后两位       |
| -1         |                           {:+.2f}                            | -1.00                                         | 带符号保留小数点后两位       |
| 2.71828    |                            {:.0f}                            | 3                                             | 不带小数                     |
| 5          |                           {:0>2d}                            | 05                                            | 数字补零 (填充左边, 宽度为2) |
| 5          |                           {:x<4d}                            | 5xxx                                          | 数字补x (填充右边, 宽度为4)  |
| 10         |                           {:x<4d}                            | 10xx                                          | 数字补x (填充右边, 宽度为4)  |
| 1000000    |                             {:,}                             | 1,000,000                                     | 以逗号分隔的数字格式         |
| 0.25       |                            {:.2%}                            | 25.00%                                        | 百分比格式                   |
| 1000000000 |                            {:.2e}                            | 1.00e+09                                      | 指数记法                     |
| 13         |                           {:>10d}                            | 13                                            | 右对齐 (默认, 宽度为10)      |
| 13         |                           {:<10d}                            | 13                                            | 左对齐 (宽度为10)            |
| 13         |                           {:^10d}                            | 13                                            | 中间对齐 (宽度为10)          |
| 11         | `'{:b}'.format(11)` <br/>` '{:d}'.format(11)`<br/>` '{:o}'.format(11)`<br/>` '{:x}'.format(11)`<br/>` '{:#x}'.format(11)`<br/>` '{:#X}'.format(11)` | 1011<br/> 11<br/> 13<br/> b<br/> 0xb<br/> 0XB | 进制                         |

**^**, **<**, **>** 分别是居中、左对齐、右对齐，后面带宽度， **:** 号后面带填充的字符，只能是一个字符，不指定则默认是用空格填充。

**+** 表示在正数前显示 **+**，负数前显示 **-**；  （空格）表示在正数前加空格

b、d、o、x 分别是二进制、十进制、八进制、十六进制。

此外我们可以使用大括号 **{}** 来转义大括号，如下实例：

`print ("{} 对应的位置是 {{0}}".format("runoob"))`

###### 单行定义多变量并赋值

你甚至可以在一行内将多个值赋值给多个变量(元组封装和拆封)。

> 要明白这是怎么工作的，你需要学习元组（*tuple*）这个数据类型。我们是用逗号创建元组。在赋值语句的右边我们创建了一个元组，我们称这为元组封装（*tuple packing*），赋值语句的左边我们则做的是元组拆封 （*tuple unpacking*）。

```python
>>> a , b = 45, 54
>>> a
45
>>> b
54
```

这个技巧用来交换两个数的值非常方便。

```
>>> a, b = b , a
>>> a
54
>>> b
45
```



##### 运算符和表达式

`/ :除法`

`// : 整除`

###### 关系、逻辑运算

对于逻辑 与，或，非，我们使用 `and`，`or`，`not` 这几个关键字

逻辑运算符的优先级又低于关系运算符，在它们之中，`not` 具有最高的优先级，`or` 优先级最低，所以 `A and not B or C` 等于 `(A and (notB)) or C`

###### 表达式

简写运算符:

*x op= expression* 为简写运算的语法形式。其等价于 *x = x op expression* 

```
>>> a = 12
>>> a += 13
>>> a
25
```

###### 类型转换

我们可以手动的执行类型转换。

| 类型转换函数    | 转换路径         |
| --------------- | ---------------- |
| `float(string)` | 字符串 -> 浮点值 |
| `int(string)`   | 字符串 -> 整数值 |
| `str(integer)`  | 整数值 -> 字符串 |
| `str(float)`    | 浮点值 -> 字符串 |







##### 序列（列表）操作

列表的数据结构。它可以写作中括号之间的一列逗号分隔的值。列表的元素不必是同一类型：

```
>>> a = [ 1, 342, 223, 'India', 'Fedora']
>>> a
[1, 342, 223, 'India', 'Fedora']
```

负数的索引，那将会从列表的末尾`-1`开始计数
正数的索引，那将会从列表的开头`0`开始计数

```
 +---+-----+-----+---------+----------+
 | 1 | 342 | 223 | 'India' | 'Fedora' |
 +---+-----+-----+---------+----------+
   0    1     2       3        4          5
  -5   -4    -3      -2       -1
```

试图使用太大的索引会导致错误：

```
>>> a[32]
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IndexError: list index out of range
```

###### 切片

甚至可以把它切成不同的部分，这个操作称为切片，例子在下面给出：

```
>>> a = [ 1, 342, 223, 'India', 'Fedora']
>>> a[0:-1]
[1, 342, 223, 'India']
>>> a[2:-2]
[223]
```

切片并不会改变正在操作的列表，切片操作返回其子列表，这意味着下面的切片操作返回列表一个新的（栈）拷贝副本

切片的索引有非常有用的默认值；**省略的第一个索引默认为零，省略的第二个索引默认为切片的字符串的大小**

**Python 中有关下标的集合都满足左闭右开原则，切片中也是如此，也就是说集合左边界值能取到，右边界值不能取到。**

Python 能够优雅地处理那些没有意义的切片索引：一个过大的索引值(即大于列表实际长度)将被列表实际长度所代替，当上边界比下边界大时(即切片左值大于右值)就返回空列表:

```
>>> a[2:32]
[223, 'India', 'Fedora']
>>> a[32:]
[]
```

###### 切片步长

切片操作还可以设置步长，就像下面这样：

```
>>> a[1::2]
[342, 'India']
```

它的意思是，从切片索引 1 到列表末尾，每隔两个元素取值。

###### 列表拼接

列表也支持连接这样的操作，它返回一个新的列表：

```
>>> a + [36, 49, 64, 81, 100]
[1, 342, 223, 'India', 'Fedora', 36, 49, 64, 81, 100]
```

###### 列表赋值

也可以对切片赋值，此操作可以改变列表的尺寸，或清空它：

```
>>> letters = ['a', 'b', 'c', 'd', 'e', 'f', 'g']
>>> letters
['a', 'b', 'c', 'd', 'e', 'f', 'g']
>>> # 替换某些值
>>> letters[2:5] = ['C', 'D', 'E']
>>> letters
['a', 'b', 'C', 'D', 'E', 'f', 'g']
>>> # 现在移除他们
>>> letters[2:5] = []
>>> letters
['a', 'b', 'f', 'g']
>>> # 通过替换所有元素为空列表来清空这个列表
>>> letters[:] = []
>>> letters
[]
```

> 细心的同学可能发问了，前面不是说过切片操作不改变列表么？严格来说，这里并不算真正的切片操作，只是上面代码中赋值运算符左边的这种操作与切片操作形式一样而已。

![img](data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgdmlld0JveD0iMCAwIDIwIDIwIj4KICAgIDxnIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCI+CiAgICAgICAgPHBhdGggZmlsbD0iI0ZGRiIgc3Ryb2tlPSIjQzZDNkM2IiBzdHJva2Utd2lkdGg9IjEuMyIgZD0iTTEwIDE3LjgzOWw4LjA2NC0xLjQ5M2EuMzUuMzUgMCAwIDAgLjI4Ni0uMzQ0di0xMy4zYS4zNS4zNSAwIDAgMC0uNDE0LS4zNDRsLTcuOCAxLjQ0NGMtLjEzNi4wMTctLjEzNi4wMTctLjI3MyAwbC03LjgtMS40NDRhLjM1LjM1IDAgMCAwLS40MTMuMzQ0djEzLjNjMCAuMTY4LjEyLjMxMy4yODYuMzQ0TDEwIDE3LjgzOXoiLz4KICAgICAgICA8cGF0aCBmaWxsPSIjQzZDNkM2IiBkPSJNOS41IDEzLjVoMXYxaC0xdi0xem0xLjcxNy00LjY5NGMwLS43MDItLjQyOC0xLjE5Mi0xLjI3NS0xLjE5Mi0uNjEyIDAtMS4xNTkuMjkxLTEuNjc4Ljg2NUw3LjUgNy43NjRDOC4xNzEgNy4wMTcgOC45OTQgNi41IDEwLjA5NCA2LjVjMS40MzUgMCAyLjQwNi44MDggMi40MDYgMi4xOTggMCAxLjc3OC0yLjI5IDIuMDgxLTIuMDUgMy44MDJIOS4yN2MtLjMxMS0xLjkyOCAxLjk0Ny0yLjQxNyAxLjk0Ny0zLjY5NHoiLz4KICAgIDwvZz4KPC9zdmc+Cg==)

![img](https://static.shiyanlou.com/frontend/dist/img/cc491c4.svg)

![img](data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgdmlld0JveD0iMCAwIDIwIDIwIj4KICAgIDxnIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCIgc3Ryb2tlPSIjQzZDNkM2Ij4KICAgICAgICA8cGF0aCBmaWxsPSIjQzZDNkM2IiBzdHJva2Utd2lkdGg9Ii43IiBkPSJNMTMuOTIyIDQuMjN2Ni4xNDhhLjU1LjU1IDAgMCAxLS41NS41NUg4LjcwNHY1LjQ3OGEuNTUuNTUgMCAwIDEtLjU1LjU1SDMuNWEuMTUuMTUgMCAwIDAtLjE1LjE1di40MzRjMCAuMDgzLjA2Ny4xNS4xNS4xNWg1LjgwMnYtNS40NzhhLjU1LjU1IDAgMCAxIC41NS0uNTVoNC42NjdWNS41MTRhLjU1LjU1IDAgMCAxIC41NS0uNTVIMTkuNWEuMTUuMTUgMCAwIDAgLjE1LS4xNVY0LjM4YS4xNS4xNSAwIDAgMC0uMTUtLjE1aC01LjU3OHoiLz4KICAgICAgICA8cGF0aCBzdHJva2UtbGluZWpvaW49InJvdW5kIiBzdHJva2Utd2lkdGg9IjEuMiIgZD0iTTYuMzUgNS4xM0w0Ljc0OCA0LjA0NGMtLjE2Ni0uMTQ4LS4xNjYtLjE0OC0uMjQxLS4zMjZhLjYxMy42MTMgMCAwIDEgLjMzMy0uNzQ1bC4xMDktLjAzNiA0LjYzNS0xLjA5MmEuNzIuNzIgMCAwIDEgLjkyNi42MjRsLjU1MyA0LjYwMWMuMDAyLjE1Ny4wMDIuMTU3LS4wNS4zMTFhLjYxLjYxIDAgMCAxLS44ODguMjY4bC0xLjM5Mi0uODljLS41MDkuODgtMS41OTUgMi4yMjgtMi42MzIgMy4wNi0xLjM5IDEuMTE3LTIuODk4IDEuODc1LTQuNTIyIDIuMjdsLS4zOS0xLjEyOWMxLjc5OS0uODE2IDMuMDUzLTEuNzI0IDMuNzctMi43MDdBOC4xMDYgOC4xMDYgMCAwIDAgNi4zNSA1LjEyOXoiLz4KICAgIDwvZz4KPC9zdmc+Cg==)



三、列表



在继续学习循环之前，我们先学习一个叫做列表的数据结构。它可以写作中括号之间的一列逗号分隔的值。列表的元素不必是同一类型：

```
>>> a = [ 1, 342, 223, 'India', 'Fedora']
>>> a
[1, 342, 223, 'India', 'Fedora']
```

你可以将上面的列表想象为一堆有序的盒子，盒子包含有上面提到的值，每个盒子都有自己的编号（红色的数字），编号从零开始，你可以通过编号访问每一个盒子里面的值。对于列表，这里的编号称为索引。

![6-3-1](http://labfile.oss.aliyuncs.com/courses/596/Welcome%20to%20Python%20for%20you%20and%20me%20-%20%E5%BE%AA%E7%8E%AF_img_1.png)

我们像下面这样通过索引来访问列表中的每一个值：

```
>>> a[0]
1
>>> a[4]
'Fedora'
```

如果我们使用负数的索引，那将会从列表的末尾开始计数，像下面这样：

```
>>> a[-1]
'Fedora'
```

你甚至可以把它切成不同的部分，这个操作称为切片，例子在下面给出：

```
>>> a[0:-1]
[1, 342, 223, 'India']
>>> a[2:-2]
[223]
```

切片并不会改变正在操作的列表，切片操作返回其子列表，这意味着下面的切片操作返回列表一个新的（栈）拷贝副本：

```
>>> a[:]
[1, 342, 223, 'India', 'Fedora']
```

切片的索引有非常有用的默认值；省略的第一个索引默认为零，省略的第二个索引默认为切片的字符串的大小：

```
>>> a[:-2]
[1, 342, 223]
>>> a[-2:]
['India', 'Fedora']
```

有个办法可以很容易地记住切片的工作方式：切片时的索引是在两个元素之间 。左边第一个元素的索引为 0，而长度为 n 的列表其最后一个元素的右界索引为 n。例如：

```
 +---+-----+-----+---------+----------+
 | 1 | 342 | 223 | 'India' | 'Fedora' |
 +---+-----+-----+---------+----------+
   0    1     2       3        4          5
  -5   -4    -3      -2       -1
```

上面的第一行数字给出列表中的索引点 0...5。第二行给出相应的负索引。切片是从 i 到 j 两个数值表示的边界之间的所有元素。

对于非负索引，如果上下都在边界内，切片长度就是两个索引之差。例如 `a[2:4]` 是 2。

Python 中有关下标的集合都满足左闭右开原则，切片中也是如此，也就是说集合左边界值能取到，右边界值不能取到。

对上面的列表， `a[0:5]` 用数学表达式可以写为 `[0,5)` ，其索引取值为 `0,1,2,3,4`，所以能将`a`中所有值获取到。 你也可以用`a[:5]`, 效果是一样的。

而`a[-5:-1]`，因为左闭右开原则，其取值为 `-5,-4,-3,-2` 是不包含 `-1` 的。

为了取到最后一个值，你可以使用 `a[-5:]` ，它代表了取该列表最后5个值。

试图使用太大的索引会导致错误：

```
>>> a[32]
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IndexError: list index out of range
>>> a[-10]
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IndexError: list index out of range
```

Python 能够优雅地处理那些没有意义的切片索引：一个过大的索引值(即大于列表实际长度)将被列表实际长度所代替，当上边界比下边界大时(即切片左值大于右值)就返回空列表:

```
>>> a[2:32]
[223, 'India', 'Fedora']
>>> a[32:]
[]
```

切片操作还可以设置步长，就像下面这样：

```
>>> a[1::2]
[342, 'India']
```

它的意思是，从切片索引 1 到列表末尾，每隔两个元素取值。

列表也支持连接这样的操作，它返回一个新的列表：

```
>>> a + [36, 49, 64, 81, 100]
[1, 342, 223, 'India', 'Fedora', 36, 49, 64, 81, 100]
```

列表允许修改元素：

```
>>> cubes = [1, 8, 27, 65, 125]
>>> cubes[3] = 64
>>> cubes
[1, 8, 27, 64, 125]
```

也可以对切片赋值，此操作可以改变列表的尺寸，或清空它：

```
>>> letters = ['a', 'b', 'c', 'd', 'e', 'f', 'g']
>>> letters
['a', 'b', 'c', 'd', 'e', 'f', 'g']
>>> # 替换某些值
>>> letters[2:5] = ['C', 'D', 'E']
>>> letters
['a', 'b', 'C', 'D', 'E', 'f', 'g']
>>> # 现在移除他们
>>> letters[2:5] = []
>>> letters
['a', 'b', 'f', 'g']
>>> # 通过替换所有元素为空列表来清空这个列表
>>> letters[:] = []
>>> letters
[]
```

细心的同学可能发问了，前面不是说过切片操作不改变列表么？严格来说，这里并不算真正的切片操作，只是上面代码中赋值运算符左边的这种操作与切片操作形式一样而已。

###### 元素包含

要检查某个值是否存在于列表中，你可以这样做：

```
>>> a = ['ShiYanLou', 'is', 'cool']
>>> 'cool' in a
True
>>> 'Linux' in a
False
```



##### 控制流和循环

```
if expression:
	do this
else:
	do that
--------------------------
if expression1:
	do this
elif expression2:
	do ...
else:
	do that
```



`while` 语句的语法如下：

```
while condition:
    statement1
    statement2
```

关键字 `break`，它可以终止最里面的循环



for 循环遍历任何序列（比如列表和字符串）中的每一个元素。下面给出示例：

```
>>> a = ['ShiYanLou', 'is', 'powerful']
>>> for x in a:
...     print(x)
...
ShiYanLou
is
powerful
```

我们也能这样做：

```
>>> a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
>>> for x in a[::2]:
...     print(x)
1
3
5
7
9
```

###### range() 函数

如果你需要一个数值序列，内置函数 [range()](https://docs.python.org/3/library/stdtypes.html#range) 会很方便，它生成一个等差数列（并不是列表）：

```
>>> range(1, 5)      
range(1, 5)
>>> list(range(1, 5))
[1, 2, 3, 4]
>>> list(range(1, 15, 3))
[1, 4, 7, 10, 13]
```

###### 循环的`else` 语句

> 我们可以再循环后面使用可选的`else`,它将再循环执行完毕后执行，除非有`break`语句终止了循环
>
>  python 中 `for` 循环的 `else` 子句给我们提供了检测循环是否顺利执行完毕的一种优雅方法。 

##### 数据结构

###### 列表

`append()` :  添加元素 到列表末尾 
`insert()`:  将数据插入到列表的指定位置 
`count()`:  元素在列表中出现了多少次 
`remove()`:  在列表中移除任意指定值 
`reverse()`:  反转整个列表 
`extend()`:  将一个列表的所有元素添加到另一个列表的末尾 
`sort()`:  列表排序， 前提是列表的元素是可比较的 
`del`关键字：删除指定位置的列表元素 

###### 将列表用作栈和队列

栈： 一种 *LIFO* （Last In First Out 后进先出）数据结构 



```python
>>> a = [1, 2, 3, 4, 5, 6]
>>> a
[1, 2, 3, 4, 5, 6]
>>> a.pop()
6
>>> a.pop()
5
>>> a.pop()
4
>>> a.pop()
3
>>> a
[1, 2]
>>> a.append(34)
>>> a
[1, 2, 34]
```

 上面的代码中我们使用了一个新方法 `pop()`。传入一个参数 i 即 `pop(i)` 会将第 i 个元素弹出。 

队列： 它是 *FIFO* （First In First Out 先进先出）的数据结构 

```python
>>> a = [1, 2, 3, 4, 5]
>>> a.append(1)
>>> a
[1, 2, 3, 4, 5, 1]
>>> a.pop(0)
1
>>> a.pop(0)
2
>>> a
[3, 4, 5, 1]
```

 我们使用 `a.pop(0)` 弹出列表中第一个元素。 

###### 列表推导式

 列表推导式由包含一个表达式的中括号组成，表达式后面跟随一个 for 子句，之后可以有零或多个 for 或 if 子句。结果是一个列表，由表达式依据其后面的 for 和 if 子句上下文计算而来的结果构成。 

```python
squares = [x**2 for x in range(10)]

>>> [(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]
[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]

# 列表推导式也可以嵌套
>>> a=[1,2,3]
>>> z = [x + 1 for x in [x ** 2 for x in a]]
>>> z
[2, 5, 10]
```

###### 元组

+  元组是由数个逗号分割的值组成 
+  可以对任何一个元组执行拆封操作并赋值给多个变量 
+  元组是不可变类型，这意味着你不能在元组内删除或添加或编辑任何值 
+  要创建只含有一个元素的元组，在值后面跟一个逗号 

###### 集合

> 集合是一个无序不重复元素的集。基本功能包括关系测试和消除重复元素。集合对象还支持 union（联合），intersection（交），difference（差）和 symmetric difference（对称差集）等数学运算。 

 大括号或 set() 函数可以用来创建集合。注意：想要创建空集合，你必须使用 set() 而不是 {}。后者用于创建空字典 

```python
>>> # 演示对两个单词中的字母进行集合操作
...
>>> a = set('abracadabra')
>>> b = set('alacazam')
>>> a                                  # a 去重后的字母
{'a', 'r', 'b', 'c', 'd'}
>>> a - b                              # a 有而 b 没有的字母
{'r', 'd', 'b'}
>>> a | b                              # 存在于 a 或 b 的字母
{'a', 'c', 'r', 'd', 'b', 'm', 'z', 'l'}
>>> a & b                              # a 和 b 都有的字母
{'a', 'c'}
>>> a ^ b                              # 存在于 a 或 b 但不同时存在的字母
{'r', 'd', 'b', 'm', 'z', 'l'}
```

 从集合中添加或弹出元素： 

```python
>>> a = {'a','e','h','g'}
>>> a.pop()  # pop 方法随机删除一个元素并打印
'h'
>>> a.add('c')
>>> a
{'c', 'e', 'g', 'a'}
```

###### 字典

> 字典是是无序的键值对（`key:value`）集合，同一个字典内的键必须是互不相同的。一对大括号 `{}` 创建一个空字典。初始化字典时，在大括号内放置一组逗号分隔的键：值对，这也是字典输出的方式。我们使用键来检索存储在字典中的数据。 

```
>>> data = {'kushal':'Fedora', 'kart_':'Debian', 'Jace':'Mac'}
>>> data
{'kushal': 'Fedora', 'Jace': 'Mac', 'kart_': 'Debian'}
>>> data['kart_']
'Debian'
```

创建新的键值对很简单：

```
>>> data['parthan'] = 'Ubuntu'
>>> data
{'kushal': 'Fedora', 'Jace': 'Mac', 'kart_': 'Debian', 'parthan': 'Ubuntu'}
```

使用 `del` 关键字删除任意指定的键值对：

```
>>> del data['kushal']
>>> data
{'Jace': 'Mac', 'kart_': 'Debian', 'parthan': 'Ubuntu'
```

使用 `in` 关键字查询指定的键是否存在于字典中。

```
>>> 'ShiYanLou' in data
False
```

**字典中的键必须是不可变类型，比如你不能使用列表作为键**!!!

`dict()` 可以从包含键值对的元组中创建字典。

```python
>>> dict((('Indian','Delhi'),('Bangladesh','Dhaka')))
{'Indian': 'Delhi', 'Bangladesh': 'Dhaka'}
```

如果你想要遍历一个字典，使用字典的 `items()` 方法。

```
>>> data
{'Kushal': 'Fedora', 'Jace': 'Mac', 'kart_': 'Debian', 'parthan': 'Ubuntu'}
>>> for x, y in data.items():
...     print("{} uses {}".format(x, y))
...
Kushal uses Fedora
Jace uses Mac
kart_ uses Debian
parthan uses Ubuntu
```

许多时候我们需要往字典中的元素添加数据，我们首先要判断这个元素是否存在，不存在则创建一个默认值。如果在循环里执行这个操作，每次迭代都需要判断一次，降低程序性能。

我们可以使用 `dict.setdefault(key, default)` 更有效率的完成这个事情。
return： 如果字典中包含有给定键，则返回该键对应的值，否则返回为该键设置的值。 

```
>>> data = {}
>>> data.setdefault('names', []).append('Ruby')
>>> data
{'names': ['Ruby']}
>>> data.setdefault('names', []).append('Python')
>>> data
{'names': ['Ruby', 'Python']}
>>> data.setdefault('names', []).append('C')
>>> data
{'names': ['Ruby', 'Python', 'C']}
```

试图索引一个不存在的键将会抛出一个 *keyError* 错误。我们可以使用 `dict.get(key, default)` 来索引键，如果键不存在，那么返回指定的 default 值。

```
>>> data['foo']
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
KeyError: 'foo'
>>> data.get('foo', 0)
0
```

######  enumerate() 

如果你想要在遍历列表（或任何序列类型）的同时获得元素索引值，你可以使用 `enumerate()`。

```
>>> for i, j in enumerate(['a', 'b', 'c']):
...     print(i, j)
...
0 a
1 b
2 c
```

###### zip()

你也许需要同时遍历两个序列类型，你可以使用 `zip()` 函数。

```
>>> a = ['Pradeepto', 'Kushal']
>>> b = ['OpenSUSE', 'Fedora']
>>> for x, y in zip(a, b):
...     print("{} uses {}".format(x, y))
...
Pradeepto uses OpenSUSE
Kushal uses Fedora
```

##### 字符串

`split()`:  `split()` 分割任意字符串，允许有一个参数，用来指定字符串以什么字符分隔（默认为 `" "`），它返回一个包含所有分割后的字符串的列表 
`join()`: 方法 `join()` 使用指定字符连接多个字符串，它需要一个包含字符串元素的列表作为输入然后连接列表内的字符串元素 
`title()`:
`upper()`:
`swapcase()`:
 `isalnum()` :
 `isalpha()` :

```python
>>> s = "We all love Python"
>>> s.split()
['We', 'all', 'love', 'Python']

>>> "-".join("GNU/Linux is great".split())
'GNU/Linux-is-great'
```

######  字符串剥离 

字符串有几个进行剥离操作的方法。最简单的一个是 `strip(chars)`，用来剥离字符串首尾中指定的字符，它允许有一个字符串参数，这个参数为剥离哪些字符提供依据。不指定参数则默认剥离掉首尾的空格和换行符，代码如下：

```
>>> s = "  a bc\n "
>>> s.strip()
'a bc'
```

你可以使用 `lstrip(chars)` 或 `rstrip(chars)` 只对字符串左或右剥离。

```
>>> s = "www.foss.in" 
>>> s.lstrip("cwsd.") #删除在字符串左边出现的'c','w','s','d','.'字符
'foss.in'
>>> s.rstrip("cnwdi.") #删除在字符串右边出现的'c','n','w','d','i','.'字符
'www.foss'
```

 文本搜索 

```python
>>> s = "faulty for a reason"
>>> s.find("for")
7
>>> s.find("fora")
-1
>>> s.startswith("fa") # 检查字符串是否以 fa 开头
True
>>> s.endswith("reason") # 检查字符串是否以 reason 结尾
True
```

 回文检查 

```python
s = input("Please enter a string: ")
z = s[::-1]  #把输入的字符串s 进行倒序处理形成新的字符串z
if s == z:
    print("The string is a palindrome")
else:
    print("The string is not a palindrome")
```

##### 函数

局域或全局变量

```python
a = 9
def change():
    print(a)
    a = 100
change()
--------
UnboundLocalError: local variable 'a' referenced before assignment
局部变量在定义前被引用
原因是当函数中只要用到了变量 a，并且 a 出现在表达式等于号的左边，就会被当作局部变量。当执行到 print(a) 的时候会报错，因为 a 作为函数局部变量是在 print(a) 之后才定义的
```

 使用 `global` 关键字，对函数中的 `a` 标志为全局变量，让函数内部使用全局变量的 a，那么整个程序中出现的 `a` 都将是这个： 

```python
#!/usr/bin/env python3
a = 9
def change():
    global a
    print(a)
    a = 100
print("Before the function call ", a)
print("inside change function", end=' ')
change()
print("After the function call ", a)
--------------
Before the function call  9
inside change function 9
After the function call  100
```

 关键字 `global` 来告诉 a 的定义是全局的，因此在函数内部更改了 `a` 的值，函数外 `a` 的值也实际上更改了 

###### 默认参数值

+  第一个是具有默认值的参数后面不能再有普通参数，比如 `f(a,b=90,c)` 就是错误的 

+  是默认值只被赋值一次，因此如果默认值是任何可变对象时会有所不同，比如列表、字典或大多数类的实例。例如，下面的函数在后续调用过程中会累积（前面）传给它的参数 

  ```
  >>> def f(a, data=[]):
  ...     data.append(a)
  ...     return data
  ...
  >>> print(f(1))
  [1]
  >>> print(f(2))
  [1, 2]
  >>> print(f(3))
  [1, 2, 3]
  ```

  要避免这个问题，你可以像下面这样：

  ```
  >>> def f(a, data=None):
  ...     if data is None:
  ...         data = []
  ...     data.append(a)
  ...     return data
  ...
  >>> print(f(1))
  [1]
  >>> print(f(2))
  [2]
  ```

###### 关键字参数

函数可以通过*关键字参数*的形式来调用，形如 `keyword = value`。如下：

```
>>> def func(a, b=5, c=10):
...     print('a is', a, 'and b is', b, 'and c is', c)
...
>>> func(12, 24)
a is 12 and b is 24 and c is 10
>>> func(12, c = 24)
a is 12 and b is 5 and c is 24
>>> func(b=12, c = 24, a = -1)
a is -1 and b is 12 and c is 24
```

在上面的例子中你能看见调用函数时使用了变量名，比如 `func(12,c = 24)`，这样我们将 `24` 赋给 `c` 且 `b` 具有默认值。

######  强制关键字参数 

我们也能将函数的参数标记为只允许使用关键字参数。用户调用函数时将只能对每一个参数使用相应的关键字参数。（* 号后面只能使用强制关键字）

```
>>> def hello(*, name='User'):
...     print("Hello", name)
...
>>> hello('shiyanlou')
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: hello() takes 0 positional arguments but 1 was given
>>> hello(name='shiyanlou')
Hello shiyanlou
```

###### 高阶函数

高阶函数（*Higher-order function*）或仿函数（*functor*）是可以接受函数作为参数的函数：

- 使用一个或多个函数作为参数
- 返回另一个函数作为输出

Python 里的任何函数都可以作为高阶函数，下面举一个简单的例子：

```
# 创建一个函数，将参数列表中每个元素都变成全大写
>>> def high(l):
...     return [i.upper() for i in l]
...
# 创建高阶函数，接受一个函数和一个列表作为参数
>>> def test(h, l):
...     return h(l)
...
>>> l = ['python', 'Linux', 'Git']
# 运行高阶函数，返回预期的结果
>>> test(high, l)
['PYTHON', 'LINUX', 'GIT']
```

###### map函数

`map` 是一个在 Python 里非常有用的高阶函数。它接受一个函数和一个序列（迭代器）作为输入，然后对序列（迭代器）的每一个值应用这个函数，返回一个序列（迭代器），其包含应用函数后的结果。

```
>>> lst = [1, 2, 3, 4, 5]
>>> def square(num):
...     "返回所给数字的平方."
...     return num * num
...
>>> print(list(map(square, lst)))
[1, 4, 9, 16, 25]
```

 在 Python 中还有其它的高阶函数，如 [`sorted()`](https://docs.python.org/3/library/functions.html#sorted)、[`filter()`](https://docs.python.org/3/library/functions.html?highlight=sorted#filter) 以及 [`functools`](https://docs.python.org/3/library/functools.html) 模块中的函数 

`filter()`函数： `filter()`把传入的函数依次作用于每个元素，然后根据返回值是`True`还是`False`决定保留还是丢弃该元素。 

```
def is_odd(n):
    return n % 2 == 1

list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15]))
# 结果: [1, 5, 9, 15]
```

 `sorted()`函数:

```python
>>> sorted([36, 5, -12, 9, -21])
[-21, -12, 5, 9, 36]

# 它还可以接收一个key函数来实现自定义的排序，例如按绝对值大小排序
# key指定的函数将作用于list的每一个元素上，并根据key函数返回的结果进行排序
>>> sorted([36, 5, -12, 9, -21], key=abs)
[5, 9, -12, -21, 36]

# 要进行反向排序，不必改动key函数，可以传入第三个参数reverse=True
>>> sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower, reverse=True)
['Zoo', 'Credit', 'bob', 'about']
```

##### 文件处理

